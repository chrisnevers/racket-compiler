diff --git a/src/flatten.ml b/src/flatten.ml
index a2dff5a..ca80b87 100644
--- a/src/flatten.ml
+++ b/src/flatten.ml
@@ -7,6 +7,12 @@ exception FlattenError of string
 
 let flatten_error s = raise (FlattenError s)
 
+let rec get_datatype_from_list name ivars =
+  match ivars with
+  | (v, dt) :: t ->
+    if v = name then dt else get_datatype_from_list name t
+  | [] -> TypeVoid
+
 let get_var_name v name =
   match v with
   | Some name -> name
@@ -30,10 +36,10 @@ let get_ccmp_of_rcmp o : ccmp =
   | ">=" -> CGE
   | _ -> flatten_error ("get_ccmp_of_rcmp: Expected compare operator but received " ^ o)
 
-let flatten_arg ?(v=None) a : carg * cstmt list * (string * datatype) list =
+let flatten_arg ?(v=None) a dt : carg * cstmt list * (string * datatype) list =
   let flat_arg = get_carg_of_rarg a in
   let stmts = if v = None then [] else [CAssign (get_var_name v (string_of_carg_type flat_arg), CArg flat_arg)] in
-  let var_list = [] in
+  let var_list = if v != None then [(get_some v, dt)] else [] in
   (flat_arg, stmts, var_list)
 
 (* let rec flatten_exp ?(v=None) e : carg * cstmt list * (string * datatype) list = *)
@@ -44,7 +50,7 @@ let rec flatten_typed_exp ?(v=None) exp =
   | TypeIs (Some dt, e) -> (
     match e with
     | RVar _ | RInt _ | RBool _ | RVoid | RGlobalValue _ ->
-      flatten_arg e ~v:v
+      flatten_arg e dt ~v:v
     | RAnd (l, r) ->
       let (larg, lstmts, lvars) = flatten_typed_exp l in
       let (rarg, rstmts, rvars) = flatten_typed_exp r in
@@ -58,7 +64,7 @@ let rec flatten_typed_exp ?(v=None) exp =
       let lif = CIf (lif_cnd, rstmts @ [rif], [CAssign (var_name, CArg (CBool false))]) in
       (* Execute lstmts see if left is true *)
       let stmts = lstmts @ [lif] in
-      let var_list = if v = None then (var_name, dt) :: lvars @ rvars else lvars @ rvars in
+      let var_list = (var_name, dt) :: lvars @ rvars in
       (flat_arg, stmts, var_list)
     | ROr (l, r) ->
       let (larg, lstmts, lvars) = flatten_typed_exp l in
@@ -73,14 +79,14 @@ let rec flatten_typed_exp ?(v=None) exp =
       let lif = CIf (lif_cnd, [CAssign (var_name, CArg (CBool true))], rstmts @ [rif]) in
       (* Execute lstmts see if left is true *)
       let stmts = lstmts @ [lif] in
-      let var_list = if v = None then (var_name, dt) :: lvars @ rvars else lvars @ rvars in
+      let var_list = (var_name, dt) :: lvars @ rvars in
       (flat_arg, stmts, var_list)
     | RNot e ->
       let (earg, estmts, evars) = flatten_typed_exp e in
       let var_name = get_var_name v "not" in
       let flat_arg = CVar var_name in
       let stmts = estmts @ [CAssign (var_name, CNot earg)] in
-      let var_list = if v = None then (var_name, dt) :: evars else evars in
+      let var_list = (var_name, dt) :: evars in
       (flat_arg, stmts, var_list)
     | RIf (cnd, thn, els) ->
       let var_name = get_var_name v "if" in
@@ -91,7 +97,7 @@ let rec flatten_typed_exp ?(v=None) exp =
       let if_cnd = CCmp (CEq, CBool true, cnd_arg) in
       let flat_arg = CVar var_name in
       let stmts = cnd_stmts @ [CIf (if_cnd, thn_stmts, els_stmts)] in
-      let var_list = if v = None then (var_name, dt) :: cnd_vars @ thn_vars @ els_vars else cnd_vars @ thn_vars @ els_vars in
+      let var_list = (var_name, dt) :: cnd_vars @ thn_vars @ els_vars in
       (flat_arg, stmts, var_list)
     | RWhile (cnd, thn) ->
       let var_name = get_var_name v "while" in
@@ -100,7 +106,7 @@ let rec flatten_typed_exp ?(v=None) exp =
       let while_cnd = CCmp (CEq, CBool true, cnd_arg) in
       let flat_arg = CVar var_name in
       let stmts = [CAssign (var_name, CArg (CVoid)); CWhile (cnd_stmts, while_cnd, thn_stmts)] in
-      let var_list = if v = None then (var_name, dt) :: cnd_vars @ thn_vars else cnd_vars @ thn_vars in
+      let var_list = (var_name, dt) :: cnd_vars @ thn_vars in
       (flat_arg, stmts, var_list)
     | RCmp (o, l, r) ->
       let (larg, lstmts, lvars) = flatten_typed_exp l in
@@ -109,14 +115,14 @@ let rec flatten_typed_exp ?(v=None) exp =
       let flat_arg = CVar var_name in
       let ccmp = get_ccmp_of_rcmp o in
       let stmts = lstmts @ rstmts @ [CAssign (var_name, CCmp (ccmp, larg, rarg))] in
-      let var_list = if v = None then (var_name, dt) :: lvars @ rvars else lvars @ rvars in
+      let var_list = (var_name, dt) :: lvars @ rvars in
       (flat_arg, stmts, var_list)
     | RUnOp (o, e) ->
       let (earg, estmts, evars) = flatten_typed_exp e in
       let var_name = get_var_name v "unop" in
       let flat_arg = CVar var_name in
       let stmts = estmts @ [CAssign (var_name, CUnOp (o, earg))] in
-      let var_list = if v = None then (var_name, dt) :: evars else evars in
+      let var_list = (var_name, dt) :: evars in
       (flat_arg, stmts, var_list)
     | RBinOp (o, l, r) ->
       let (larg, lstmts, lvars) = flatten_typed_exp l in
@@ -124,7 +130,7 @@ let rec flatten_typed_exp ?(v=None) exp =
       let var_name = get_var_name v "binop" in
       let flat_arg = CVar var_name in
       let stmts = lstmts @ rstmts @ [CAssign (var_name, CBinOp (o, larg, rarg))] in
-      let var_list = if v = None then (var_name, dt) :: lvars @ rvars else lvars @ rvars in
+      let var_list = (var_name, dt) :: lvars @ rvars in
       (flat_arg, stmts, var_list)
     | RLet (name, i, b) ->
       (* Assign result of inner expression to the variable being declared *)
@@ -133,13 +139,15 @@ let rec flatten_typed_exp ?(v=None) exp =
       let (barg, bstmts, bvars) = flatten_typed_exp b ~v:v in
       let flat_arg = barg in
       let stmts = istmts @ bstmts in
+      (* Var should be of inner expression datatype *)
+      let dt = get_datatype_from_list name ivars in
       let var_list = (name, dt) :: ivars @ bvars in
       (flat_arg, stmts, var_list)
     | RRead ->
       let var_name = get_var_name v "read" in
       let flat_arg = CVar var_name in
       let stmts = [CAssign (var_name, CRead)] in
-      let var_list = if v = None then [(var_name, dt)] else [] in
+      let var_list = [(var_name, dt)] in
       (flat_arg, stmts, var_list)
     | RPrint e ->
       let (earg, estmts, evars) = flatten_typed_exp e in
@@ -148,7 +156,7 @@ let rec flatten_typed_exp ?(v=None) exp =
       let flat_arg = CVar var_name in
       (* Revisit assign to void? *)
       let stmts = estmts @ [CAssign (var_name, CPrint (edt, earg))] in
-      let var_list = if v = None then (var_name, dt) :: evars else evars in
+      let var_list = (var_name, dt) :: evars in
       (flat_arg, stmts, var_list)
     | RVectorSet (vec, i, e) ->
       let (varg, vstmts, vvars) = flatten_typed_exp vec in
@@ -162,14 +170,14 @@ let rec flatten_typed_exp ?(v=None) exp =
       let (varg, vstmts, vvars) = flatten_typed_exp ve in
       let flat_arg = CVar var_name in
       let stmts = vstmts @ [CAssign (var_name, CVectorRef (varg, i))] in
-      let var_list = if v = None then (var_name, dt) :: vvars else vvars in
+      let var_list = (var_name, dt) :: vvars in
       (flat_arg, stmts, var_list)
     | RCollect i -> (CVoid, [CCollect i], [])
     | RAllocate (i, ty) ->
       let var_name = get_var_name v "alloc" in
       let flat_arg = CVar var_name in
       let stmts = [CAssign (var_name, CAlloc (i, ty))] in
-      let var_list = if v = None then [(var_name, dt)] else [] in
+      let var_list = [(var_name, dt)] in
       (flat_arg, stmts, var_list)
     (* Invalid expressions *)
     | RVector _ -> flatten_error "should not have vector in flatten"
